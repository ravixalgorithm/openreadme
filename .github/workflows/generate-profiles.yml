name: Generate Profile Images

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    # Run at 00:00 UTC every day
    - cron: '0 0 * * *'

permissions:
  contents: write  # Required for pushing changes
  pull-requests: write  # Required for creating pull requests
  packages: read  # Required for reading package information
  actions: read

jobs:
  generate-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.IMAGE_TOKEN || github.token }}
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Read user mappings
        id: user-mappings
        run: |
          # Read the user-mapping.json file
          MAPPINGS=$(jq -r 'to_entries | map("\(.key)=\(.value)") | join(" ")' data/user-mapping.json)
          echo "mappings=${MAPPINGS}" >> $GITHUB_OUTPUT

      - name: Generate profile images
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Install required dependencies
          npm install node-fetch@2

          # Create the generation script
          cat > generate-images.js << 'EOL'
          const fs = require('fs');
          const fetch = require('node-fetch');

          // Get the API URL from environment variables
          const API_URL = https://openreadme.vercel.app/api/openreadme || 'http://localhost:3000';
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

          async function generateProfileImage(username, userId) {
            try {
              console.log(`üé® Generating image for ${username} (${userId})...`);

              // First, get the user data from GitHub API
              const userResponse = await fetch(`https://api.github.com/users/${username}`, {
                headers: {
                  'Authorization': `token ${GITHUB_TOKEN}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'User-Agent': 'OpenReadme-Workflow'
                }
              });

              if (!userResponse.ok) {
                console.warn(`‚ö†Ô∏è  GitHub API warning for ${username}: ${userResponse.statusText}`);
                // Continue with basic data if GitHub API fails
              }

              const userData = userResponse.ok ? await userResponse.json() : { login: username };

              // Prepare the data for the OpenReadme API (using POST method)
              const requestBody = {
                username: username,
                github: username
              };

              // Add query parameters for additional data
              const params = new URLSearchParams({
                n: userData.name || username,
                i: userData.avatar_url || '',
                g: username,
                x: userData.twitter_username || '',
                l: userData.blog || userData.html_url || '',
                p: userData.html_url || `https://github.com/${username}`,
                t: 'classic'
              });

              const apiUrl = `${API_URL}?${params.toString()}`;
              console.log(`üì° Calling API: ${apiUrl}`);

              // Call the OpenReadme API with POST method (as per your route.ts)
              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                  'Accept': 'application/json',
                  'Content-Type': 'application/json',
                  'User-Agent': 'OpenReadme-Workflow'
                },
                body: JSON.stringify(requestBody)
              });

              console.log(`üìä Response status: ${response.status} ${response.statusText}`);

              if (!response.ok) {
                const errorText = await response.text();
                console.error(`‚ùå API error response: ${errorText}`);
                throw new Error(`API error (${response.status}): ${errorText}`);
              }

              const result = await response.json();
              console.log(`‚úÖ Successfully generated image for ${username}`);
              console.log(`üîó Image URL: ${result.url}`);
              console.log(`üìù Method: ${result.method}`);

              return result.url;

            } catch (error) {
              console.error(`‚ùå Error generating image for ${username}:`, error.message);
              console.error(`üîç Stack trace:`, error.stack);
              return null;
            }
          }

          // Process all users
          (async () => {
            try {
              const mappingsString = process.env.MAPPINGS || '';
              const mappings = mappingsString.split(' ').filter(m => m.trim());
              console.log(`üìã Found ${mappings.length} users to process`);
              console.log(`üîß Using API URL: ${API_URL}`);

              if (mappings.length === 0) {
                console.log('‚ö†Ô∏è  No user mappings found to process');
                return;
              }

              let successCount = 0;
              let errorCount = 0;

              for (const mapping of mappings) {
                if (!mapping.trim()) continue;

                const [username, userId] = mapping.split('=');
                if (!username || !userId) {
                  console.warn(`‚ö†Ô∏è  Invalid mapping format: ${mapping}`);
                  continue;
                }

                console.log(`\n${'='.repeat(50)}`);
                console.log(`üîÑ Processing ${username} (${userId})`);
                console.log(`${'='.repeat(50)}`);

                try {
                  const imageUrl = await generateProfileImage(username, userId);
                  if (imageUrl) {
                    successCount++;
                    console.log(`‚úÖ Success for ${username}: ${imageUrl}`);
                  } else {
                    errorCount++;
                    console.log(`‚ùå Failed for ${username}`);
                  }

                  // Add delay to avoid rate limiting (2 seconds between requests)
                  console.log(`‚è≥ Waiting 2 seconds before next request...`);
                  await new Promise(resolve => setTimeout(resolve, 2000));

                } catch (error) {
                  errorCount++;
                  console.error(`üí• Error processing ${username}:`, error.message);
                }
              }

              console.log(`\n${'='.repeat(60)}`);
              console.log(`üìä WORKFLOW SUMMARY`);
              console.log(`${'='.repeat(60)}`);
              console.log(`‚úÖ Successful: ${successCount}`);
              console.log(`‚ùå Failed: ${errorCount}`);
              console.log(`üìã Total: ${successCount + errorCount}`);
              console.log(`${'='.repeat(60)}`);

            } catch (error) {
              console.error('üí• Workflow failed:', error.message);
              process.exit(1);
            }
          })();
          EOL

          # Run the generation script with your deployed URL
          # TODO: Replace with your actual Vercel deployment URL
          MAPPINGS="${{ steps.user-mappings.outputs.mappings }}" \
          API_URL="https://openreadme.vercel.app/api/openreadme" \
          node generate-images.js

      - name: Pull latest changes
        run: git pull origin main --rebase
      - name: Commit and push changes
        if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN || secrets.IMAGE_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions@github.com"
          git config --global --add safe.directory /github/workspace
          git add .
          git diff --quiet && git diff --staged --quiet || \
            (git commit -m "chore: update profile images [skip ci]" && \
             git push https://${{ github.actor }}:$GITHUB_TOKEN@github.com/${{ github.repository }}.git HEAD:main)
