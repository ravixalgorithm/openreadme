name: Generate Profile Images

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    # Run at 00:00 UTC every day
    - cron: '0 0 * * *'

permissions:
  contents: write
  pull-requests: write
  packages: read
  actions: read

jobs:
  generate-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.IMAGE_TOKEN || github.token }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Read user mappings
        id: user-mappings
        run: |
          MAPPINGS=$(jq -r 'to_entries | map("\(.key)=\(.value)") | join(" ")' data/user-mapping.json)
          echo "mappings=${MAPPINGS}" >> $GITHUB_OUTPUT

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions@github.com"
          git config --global --add safe.directory /github/workspace

      - name: Stage any existing changes
        run: |
          git config --global --add safe.directory /github/workspace
          git add .

      - name: Commit any existing changes
        run: |
          git diff-index --quiet HEAD || git commit -m "chore: update generated files [skip ci]"

      - name: Pull latest changes
        run: git pull origin main --rebase

      - name: Generate profile images
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          npm install node-fetch@2

          cat > generate-images.js << 'EOL'
          const fs = require('fs');
          const fetch = require('node-fetch');

<<<<<<< HEAD
          // Get the API URL from environment variables
          const API_URL = https://openreadme.vercel.app/api/openreadme || 'http://localhost:3000';
=======
          const API_URL = process.env.API_URL || 'http://localhost:3000';
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const REPO_OWNER = 'Open-Dev-Society';
          const REPO_NAME = 'openreadme';

          async function generateProfileImage(username, userId) {
            try {
              console.log(`üé® Generating image for ${username} (${userId})...`);

              // Get user data from GitHub API
              const userResponse = await fetch(`https://api.github.com/users/${username}`, {
                headers: {
                  'Authorization': `token ${GITHUB_TOKEN}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'User-Agent': 'OpenReadme-Workflow'
                }
              });

              if (!userResponse.ok) {
                console.warn(`‚ö†Ô∏è  GitHub API warning for ${username}: ${userResponse.statusText}`);
                // Continue with basic data if GitHub API fails
              }

              const userData = userResponse.ok ? await userResponse.json() : { login: username };

<<<<<<< HEAD
              // Prepare the data for the OpenReadme API (using POST method)
              const requestBody = {
                username: username,
                github: username
              };

              // Add query parameters for additional data
=======
              // Build API URL with repository parameters
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
              const params = new URLSearchParams({
                n: userData.name || username,
                i: userData.avatar_url || '',
                g: username,
                x: userData.twitter_username || '',
<<<<<<< HEAD
                l: userData.blog || userData.html_url || '',
                p: userData.html_url || `https://github.com/${username}`,
                t: 'classic'
=======
                l: userData.blog || userData.html_url,
                p: userData.html_url,
                t: 'classic',
                repo: `${REPO_OWNER}/${REPO_NAME}`,
                path: 'stats/usage-log.json'
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
              });

              const apiUrl = `${API_URL}?${params.toString()}`;
              console.log(`üì° Calling API: ${apiUrl}`);

<<<<<<< HEAD
              // Call the OpenReadme API with POST method (as per your route.ts)
=======
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                  'Accept': 'application/json',
                  'Content-Type': 'application/json',
<<<<<<< HEAD
                  'User-Agent': 'OpenReadme-Workflow'
                },
                body: JSON.stringify(requestBody)
=======
                  'Authorization': `token ${GITHUB_TOKEN}`
                }
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
              });

              console.log(`üìä Response status: ${response.status} ${response.statusText}`);

              if (!response.ok) {
                const errorText = await response.text();
                console.error(`‚ùå API error response: ${errorText}`);
                throw new Error(`API error (${response.status}): ${errorText}`);
              }

              const result = await response.json();
<<<<<<< HEAD
              console.log(`‚úÖ Successfully generated image for ${username}`);
              console.log(`üîó Image URL: ${result.url}`);
              console.log(`üìù Method: ${result.method}`);

=======
              console.log(`‚úÖ Successfully generated image for ${username}: ${result.url}`);
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
              return result.url;

            } catch (error) {
              console.error(`‚ùå Error generating image for ${username}:`, error.message);
              console.error(`üîç Stack trace:`, error.stack);
              return null;
            }
          }

          // Process all users
          (async () => {
            try {
              const mappingsString = process.env.MAPPINGS || '';
              const mappings = mappingsString.split(' ').filter(m => m.trim());
              console.log(`üìã Found ${mappings.length} users to process`);
              console.log(`üîß Using API URL: ${API_URL}`);

<<<<<<< HEAD
              if (mappings.length === 0) {
                console.log('‚ö†Ô∏è  No user mappings found to process');
                return;
              }

              let successCount = 0;
              let errorCount = 0;
=======
            for (const mapping of mappings) {
              if (!mapping) continue;
              const [username, userId] = mapping.split('=');
              if (!username || !userId) continue;
>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453

              for (const mapping of mappings) {
                if (!mapping.trim()) continue;

<<<<<<< HEAD
                const [username, userId] = mapping.split('=');
                if (!username || !userId) {
                  console.warn(`‚ö†Ô∏è  Invalid mapping format: ${mapping}`);
                  continue;
                }

                console.log(`\n${'='.repeat(50)}`);
                console.log(`üîÑ Processing ${username} (${userId})`);
                console.log(`${'='.repeat(50)}`);

                try {
                  const imageUrl = await generateProfileImage(username, userId);
                  if (imageUrl) {
                    successCount++;
                    console.log(`‚úÖ Success for ${username}: ${imageUrl}`);
                  } else {
                    errorCount++;
                    console.log(`‚ùå Failed for ${username}`);
                  }

                  // Add delay to avoid rate limiting (2 seconds between requests)
                  console.log(`‚è≥ Waiting 2 seconds before next request...`);
                  await new Promise(resolve => setTimeout(resolve, 2000));

                } catch (error) {
                  errorCount++;
                  console.error(`üí• Error processing ${username}:`, error.message);
                }
              }

              console.log(`\n${'='.repeat(60)}`);
              console.log(`üìä WORKFLOW SUMMARY`);
              console.log(`${'='.repeat(60)}`);
              console.log(`‚úÖ Successful: ${successCount}`);
              console.log(`‚ùå Failed: ${errorCount}`);
              console.log(`üìã Total: ${successCount + errorCount}`);
              console.log(`${'='.repeat(60)}`);

            } catch (error) {
              console.error('üí• Workflow failed:', error.message);
              process.exit(1);
            }
          })();
          EOL

          # Run the generation script with your deployed URL
          # TODO: Replace with your actual Vercel deployment URL
=======
              try {
                const imageUrl = await generateProfileImage(username, userId);
                if (imageUrl) {
                  console.log(`Image URL: ${imageUrl}`);
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (error) {
                console.error(`Error processing ${username}:`, error);
              }
            }
            console.log('\n--- All users processed ---');
          })();
          EOL

>>>>>>> b4ad3355e213c9e7566f12029203124cdbcaa453
          MAPPINGS="${{ steps.user-mappings.outputs.mappings }}" \
          API_URL="https://openreadme.vercel.app/api/openreadme" \
          node generate-images.js

      - name: Commit and push changes
        if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN || secrets.IMAGE_TOKEN }}
        run: |
          git add .
          if ! git diff-index --quiet HEAD --; then
            git commit -m "chore: update profile images [skip ci]" && \
            git push https://${{ github.actor }}:$GITHUB_TOKEN@github.com/${{ github.repository }}.git HEAD:main
          fi
